# メモリ領域

メモリの論理的がある。

領域としていくつかある。

## 領域の種類

- テキスト領域
- 静的領域
- ヒープ領域
- スタック領域

このうち、`静的領域`と`ヒープ領域`を合わせて`データ領域`と呼ばれる。なお領域はOSによって提供された仮想敵なメモリ配置となる。

## テキスト領域

- 機械語に翻訳されたプログラムが格納される。
- この機械語の命令が実行されることでプログラムが動く

## 静的領域

- グローバル変数など静的変数が置かれる

## ヒープ領域

- メモリの動的管理された変数が置かれる
- mallc関数やC++のnew演算子で確保されたメモリが対象
- アプリケーションやプログラム側で確保や解法をする。

## スタック領域

- ローカル変数などが対象
- コンパイラやOSが自動的に割り当て、解法をする。
- サイズはコンパイル、リンク時に決定する。
- 先に宣言した変数の方が大きいアドレスに配置される。(ただしコンパイラによって条件が変わる)
- 呼び出し規約が重要

# 呼び出し規約

呼び出し規約の例は[ここ](https://wiki.osdev.org/Calling_Conventions)

サンプルプログラムはWSL_memory.c

実行例は次になる。

```
mainでの呼び出し
0x7ffe926d22d4 0x7ffe926d22d8 0x7ffe926d22dc 0x7ffe926d22e0 0x7ffe926d22e4 0x7ffe926d22e8 0x7ffe926d22ec 0x7ffe926d22f0 0x7ffe926d22f4
関数内
0x7ffe926d228c 0x7ffe926d2288 0x7ffe926d2284 0x7ffe926d2280 0x7ffe926d227c 0x7ffe926d2278 0x7ffe926d22b0 0x7ffe926d22b8 0x7ffe926d22c0
関数内ローカル
0x7ffe926d2290,0x7ffe926d2294
```

これを見てみるとアドレスの順番が色々変わっている。

- mainでの呼び出し

これはint型の4バイトずつズレている。

- 関数内

左から右へ6番目のアドレスがなんと4バイトずつ減っていっている。しかし7番目から何故か8バイトずつの変化になり、更に連番法則から外れている。

- 関数内ローカル

こちらも4バイトずつズレている。

これは呼び出し規則が大きく関係して関数内などは法則性がなくなるらしい。